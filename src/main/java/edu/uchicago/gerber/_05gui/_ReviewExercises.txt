#########################################################################
# Use this file to answer Review Exercises from the Big Java textbook
#########################################################################

-----------------------------------------------------
R10.5 Events
An event object encapsulates information about a state change or an action that has occurred.It contains details
about the event. For example, in a mouse click event, the event object might contain information about the mouse's x
and y coordinates, which mouse button was clicked, how many times it was clicked, etc.
In Java's Swing library, you'll find event classes like ActionEvent, MouseEvent, KeyEvent, and many others.
An event source is the object on which the event occurs.
It's responsible for generating an event. For instance, a button in a GUI might be an event source for click events.
When a user clicks the button, the button generates (or "fires") an event.
Event sources have mechanisms to register and unregister event listeners (i.e., they keep track of which objects want
to be notified when a particular event occurs).
An event listener is an interface (or often an object implementing a specific interface) that defines methods which
will be invoked in response to certain events.
It "listens" for specific types of events and defines what action should be taken when such an event occurs.
In Java's Swing, listeners are often defined by interfaces with methods that need to be overridden.
For instance, the ActionListener interface has the actionPerformed(ActionEvent e) method, which gets called
when an action event (like a button click) happens.You attach listeners to sources. For instance, you might add
an ActionListener to a JButton so that when the button is clicked, the actionPerformed method of the listener is called.

-----------------------------------------------------
R10.6 actionPerformed
Who calls the actionPerformed method?
The Swing or AWT event dispatching system calls the actionPerformed method.
When a user interacts with a GUI component that has an associated ActionListener (like pressing a button),
the component generates an ActionEvent. The event dispatching system then notifies all registered ActionListeners
by calling their actionPerformed method, passing the ActionEvent as an argument.
When does the call to the actionPerformed method occur?
The call to the actionPerformed method occurs when an action event is generated by a GUI component. Here are some scenarios when this can happen:
A button is pressed.
A menu item is selected.
A timer fires (if you're using a javax.swing.Timer).
A user presses Enter in a text field (assuming the text field has an action listener registered).
Any other component-specific action event occurs for components that support action listeners.

-----------------------------------------------------
R10.11 Inner class and event-listeners
Inner classes, particularly anonymous inner classes, are frequently used in Java for event listeners
because they provide a concise and readable way to define and instantiate a listener directly in the
context where it's needed. They allow for direct access to the instance variables and methods of the
enclosing class, making it easy to modify the GUI or perform actions based on events without the need
for extra method calls or parameter passing.

However, if Java did not have inner classes, we could still implement event listeners.
Here are a few alternative approaches:
1. Separate Top-level Classes: We could define each listener as its own top-level class.
Each of these classes would need to implement the appropriate listener interface.
If these listeners need access to instance variables or methods of the main GUI class,
we would have to pass a reference to the main GUI class to the listener (typically via a constructor).
2. Use Lambdas (Java 8 and above): With the introduction of lambdas in Java 8,
event handling can be even more concise for functional interfaces.

-----------------------------------------------------
R10.14 Object hierarchies
Method Declared in JTextArea:

append(String str): This method appends the given String to the end of the document of the JTextArea.
Method that JTextArea Inherits from JTextComponent:
setSelectedText(String text): This method replaces the currently selected content with the new text.
Method that JTextArea Inherits from JComponent:
setToolTipText(String text): This method sets the text that is displayed when the cursor hovers over the component (creating a tooltip).

-----------------------------------------------------
R10.22 Graphic methods
We can do the modification in the following way:
public void drawFlagWithWhiteCenter(Graphics g, int xLeft, int yTop, int width, Color leftColor, Color rightColor){
    // Draw the left color
    g.setColor(leftColor);
    g.fillRect(xLeft, yTop, width/3, width*2/3);

    // Draw the white center
    g.setColor(Color.WHITE);
    g.fillRect(xLeft + width/3, yTop, width/3, width*2/3);

    // Draw the right color
    g.setColor(rightColor);
    g.fillRect(xLeft + 2*width/3, yTop, width/3, width*2/3);
}



-----------------------------------------------------
R11.2 Layout managers
Using a layout manager in Java's Swing framework offers several advantages over absolute positioning
(i.e., specifying exact x, y coordinates for each component):

Platform Independence: The same GUI might look or behave differently on various platforms.
Layout managers ensure consistent layouts across different platforms, screen resolutions, and
look-and-feel settings.

Adaptability to Window Resizing: With layout managers, when a user resizes a window, components can
adjust their sizes and positions accordingly. In contrast, components positioned with absolute
coordinates don't adapt to window resizing, which can lead to a broken or inefficient use of space
in the UI.

-----------------------------------------------------
R11.11 ButtonGroup
The behavior and intended use of radio buttons and checkboxes dictate the need for a ButtonGroup
for radio buttons but not for checkboxes.
Radio Buttons: They are used when you want to provide a set of options where the user can select only one option.
Radio buttons within a group are mutually exclusive, meaning if one is selected, all others are automatically deselected.
ButtonGroup ensures this mutual exclusivity.
Checkboxes: They are used when you want to provide a set of options where the user can select multiple options
at the same time. There's no mutual exclusivity enforced among checkboxes.

-----------------------------------------------------
R11.19 Types of Events
Both ActionEvent and MouseEvent are subclasses of the java.awt.event.AWTEvent class and are part of the Java event model,
but they represent different user interactions and are used in different contexts.
ActionEvent: Represents a high-level, semantic event, typically triggered by user interaction with a GUI component.
Examples include clicking a button, selecting an item from a list, or choosing a menu item.
MouseEvent: Represents a low-level, input-based event related specifically to mouse actions.
Examples include mouse clicks, mouse movement, mouse entering a component, and mouse exiting a component.

-----------------------------------------------------
R11.20 Events
ActionEvent:
Command String: An ActionEvent has an associated command string, which can be retrieved with the getActionCommand() method.
For example, if a button triggers the event, the command string might be the text displayed on the button.
Source Object: Like all event objects, an ActionEvent contains a reference to the object (component) that generated the event.
You can get this with the getSource() method.
Modifiers: Using the getModifiers() method, you can determine which, if any, modifier keys (like SHIFT, CTRL, ALT) were pressed
during the action.

MouseEvent:
In addition to the standard event attributes like the source object and ID, a MouseEvent carries more detailed information about the mouse
interaction:
Coordinates: The x and y coordinates of the mouse cursor at the time of the event, relative to the source component.
These can be retrieved using the getX() and getY() methods, respectively.
Button: Information about which mouse button was pressed or released. Methods like getButton() will tell you if it was the
left (MouseEvent.BUTTON1), middle (MouseEvent.BUTTON2), or right (MouseEvent.BUTTON3) button.
Click Count: The number of mouse clicks associated with the event. This can be retrieved using the getClickCount() method.
Modifiers: Much like the ActionEvent, you can determine which modifier keys were pressed (or other mouse buttons) using
the getModifiersEx() method. This gives detailed information, letting you know, for instance, if the SHIFT key was pressed
or if the right button was down.

-----------------------------------------------------
R11.21 ActionListener versus MouseListener

Purpose of ActionListener:
The ActionListener interface is designed to handle high-level, semantic actions. These are abstract actions like "submit", "cancel",
"open", etc., and don't delve into the specifics of how the action was triggered.
The main event it deals with is when a user interacts with a control in a manner that suggests they are committing to an action,
such as clicking a button or hitting the enter key in a text field. Given this high-level nature, one method (actionPerformed) is
sufficient to capture this singular, abstract idea of an action being performed.

Purpose of MouseListener:
The MouseListener interface is designed to handle low-level, detailed mouse interactions. Mouse interactions can be nuanced,
with various types of events like clicking, pressing, releasing, entering a component, or exiting a component.
Each type of interaction with the mouse might be of interest in GUI programming. For example, you might want to show a
tooltip when the mouse enters a component, begin a drag action when the mouse is pressed, or trigger some function when the
mouse is clicked. The specificity and granularity of mouse interactions necessitate multiple methods to accurately capture
 all possible events.






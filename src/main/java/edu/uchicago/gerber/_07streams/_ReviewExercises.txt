#########################################################################
# Use this file to answer Review Exercises from the Big Java textbook
#########################################################################

---------------------------------
R13.1 Terms
a. Recursion
Recursion in computer science is a method where the solution to a problem depends on solutions to smaller
instances of the same problem. A recursive function is one that calls itself during its execution.
This enables the function to repeat its actions until a base condition (also known as a base case) is met,
which is essential to prevent infinite loops. Recursive methods are commonly used for tasks such as traversing
or searching tree or graph data structures, and for problems that can naturally be divided into similar sub-problems.

b. Iteration
Iteration refers to the process of repeating a set of instructions a certain number of times or until a
specified condition is met. This is typically implemented using loops such as for, while, or do-while in
programming. Iteration is used for executing the same block of code multiple times in a row, making it a
fundamental aspect of many algorithms, especially those involving the traversal or processing of data structures
like arrays, lists, or other collections.

c. Infinite Recursion
Infinite recursion occurs when a recursive function lacks a proper base case or fails to return or progress
towards this base case. As a result, the function keeps calling itself indefinitely, leading to a stack
overflow error. This is similar to an infinite loop in iteration and is a logical error in the code.

d. Recursive Helper Method
A recursive helper method is a secondary function used in recursion, often to simplify the recursive logic
or to handle additional parameters. It's a common technique in which the main recursive method sets up the
initial conditions and then calls a helper method with additional parameters for state tracking or other
purposes. This approach is useful for encapsulating the recursive logic, keeping the main method simple,
and maintaining certain variables across recursive calls without exposing them as part of the public interface.


---------------------------------
R13.2 Smallest value

function findSmallest(arr, n):
    if n == 1:
        return arr[0]

    else:
        // Recursive call excluding the first element
        smallestInRest = findSmallest(arr, n-1)

        // Compare the first element with the smallest from the rest
        if arr[n-1] < smallestInRest:
            return arr[n-1]
        else:
            return smallestInRest



---------------------------------
R13.4 Sort array of numbers

function recursiveSort(arr, n):
    if n <= 1:
        return arr

    // Find index of the smallest element in arr[0...n-1]
    minIndex = findMinIndex(arr, n)

    // Swap the found minimum element with the first element
    swap(arr[0], arr[minIndex])

    // Recursively call the sort function on the rest of the array
    recursiveSort(arr + 1, n - 1)



---------------------------------
R13.6 Exponents recursively

function power(x, n):
    // Base Case: Any number to the power of 0 is 1
    if n == 0:
        return 1

    // Recursive Step: x^n = x * x^(n-1)
    else:
        return x * power(x, n - 1)



---------------------------------
R13.8 Factorial recursively

function factorial(n):
    // Base Case
    if n == 0:
        return 1

    // Recursive Step
    else:
        return n * factorial(n - 1)


---------------------------------
R19.1 operations on Stream<String>
a. Count of elements starting with the letter 'a':
long countStartsWithA = stream.filter(s -> s.startsWith("a")).count();

b. Count of elements of length greater than ten that start with the letter 'a':
long countLongStartsWithA = stream.filter(s -> s.startsWith("a") && s.length() > 10).count();

c. Check if there are at least 100 elements that start with the letter 'a':
boolean atLeast100StartsWithA = stream.filter(s -> s.startsWith("a")).limit(100).count() == 100;

---------------------------------
R19.3 How to read Java8
words.filter(w -> w.length() > 10).limit(100).count()

This expression first filters the stream to include only those words whose length is greater than 10.
After filtering, it limits the resulting stream to the first 100 elements.
Finally, it counts the number of elements in this limited stream.
The result is the count of up to 100 words that are longer than 10 characters from the original list.
words.limit(100).filter(w -> w.length() > 10).count()

This expression first limits the original stream to the first 100 words, regardless of their length.
Then, it filters this limited stream to include only those words whose length is greater than 10.
Finally, it counts the number of elements in this filtered stream.
The result is the count of how many of the first 100 words are longer than 10 characters.


---------------------------------
R19.6 Transforming values
Convert Stream<Double> to Stream<String>:
Use the map method to convert each Double into a String. You can use the toString method of the
Double class or the String.valueOf method.
Stream<Double> doubleStream = // your Stream<Double>;
Stream<String> stringStream = doubleStream.map(String::valueOf);
// or
Stream<String> stringStream = doubleStream.map(Object::toString);

Convert Stream<String> back to Stream<Double>:
Use the map method again, but this time to parse each String back into a Double. The Double.
parseDouble method can be used for this conversion. Note that this operation assumes all strings
in the stream are valid representations of a double value. If this might not be the case, additional
error handling should be implemented to avoid NumberFormatException.
Stream<String> stringStream = // your Stream<String>;
Stream<Double> doubleStream = stringStream.map(Double::parseDouble);


---------------------------------
R19.11 Terminal operations
Terminal operations in Java's Stream API are those that produce a result or a side-effect from a stream
 after processing elements. These operations are used with both object streams (like Stream<T>) and
 primitive-type streams (like IntStream, LongStream, DoubleStream). Here's a list of terminal operations
 that might have been discussed in your chapter, categorized by their general purpose:
Common to Both Object and Primitive-Type Streams
Reduction Operations

count(): Returns the count of elements in the stream.
min(): Returns the minimum element of the stream.
max(): Returns the maximum element of the stream.
reduce(): Performs a reduction on the elements of the stream using an associative accumulation
function and returns an Optional.
Match Operations

anyMatch(predicate): Returns true if any elements of the stream match the provided predicate.
allMatch(predicate): Returns true if all elements of the stream match the provided predicate.
noneMatch(predicate): Returns true if no elements of the stream match the provided predicate.
Collecting Operations

collect(collector): Performs a mutable reduction operation on the elements of the stream using a Collector.
Looping Operations

forEach(action): Performs an action for each element of the stream.
Short-circuit Operations

findFirst(): Returns an Optional describing the first element of the stream.
findAny(): Returns an Optional describing some element of the stream.
Specific to Object Streams
Collecting Operations
toArray(): Returns an array containing the elements of the stream.
Specific to Primitive-Type Streams
Numeric Operations

sum(): Returns the sum of elements in the stream.
average(): Returns the average of elements in the stream.
Conversion to Object Stream

boxed(): Returns a Stream<T> consisting of the elements of this stream, each boxed to an Integer, Long,
Double, etc.




---------------------------------
R19.12 Collectors
To Collection Collectors

toList(): Accumulates the input elements into a new list.
toSet(): Accumulates the input elements into a new set.
toMap(keyMapper, valueMapper): Creates a map from the stream elements.
toCollection(collectionFactory): Accumulates elements into a collection created by the provided factory.
Joining Collectors

joining(): Concatenates the input elements into a string.
joining(delimiter): Concatenates the input elements, separated by the specified delimiter.
joining(delimiter, prefix, suffix): Concatenates the input elements with a delimiter, a prefix, and a suffix.
Statistics Collectors

summarizingInt(toIntFunction): Collects statistics, like count, sum, min, average, and max, for the integer
values resulting from applying a function.
summarizingDouble(toDoubleFunction): Same as above, for double values.
summarizingLong(toLongFunction): Same as above, for long values.
Reducing Collectors

reducing(binaryOperator): Performs a reduction on the elements.
reducing(identity, binaryOperator): Performs a reduction with an identity value.
reducing(identity, mapper, binaryOperator): Applies a transformation function before reduction.
Grouping Collectors

groupingBy(classifier): Groups elements by a classifier function.
groupingBy(classifier, downstream): Groups elements, with a downstream collector applied to the values.
groupingBy(classifier, mapFactory, downstream): Groups elements, with a map factory and a downstream collector.
Partitioning Collectors

partitioningBy(predicate): Partitions elements according to a predicate.
partitioningBy(predicate, downstream): Partitions elements according to a predicate and applies a downstream collector to the values.
Mapping Collectors

mapping(mapper, downstream): Applies a mapping function to each input element, and then applies a downstream collector.
Counting Collector

counting(): Counts the number of elements.
Min/Max Collectors

minBy(comparator): Returns the minimum element according to a given comparator.
maxBy(comparator): Returns the maximum element according to a given comparator.
Custom Collector

of(supplier, accumulator, combiner, finisher): Creates a custom collector with specified supplier, accumulator, combiner, and finisher functions.
of(supplier, accumulator, combiner, finisher, characteristics): Same as above, with additional characteristics.